#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "images/title.h"
#include "images/background.h"
#include "images/lego.h"
#include "images/fly.h"


/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"


Player player;
Fly flies[MAX_FLIES];
int score;
int bestScores[LEADERBOARD_SIZE];
int timer;
int frameCounter;
u32 previousButtons;
u32 currentButtons;

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
  LEADERBOARD,
};


//function prototypes --> just writing for clarity in my mind
/**/

enum gba_state state;


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  previousButtons = BUTTONS;
  currentButtons = BUTTONS;

  for (int i = 0; i < LEADERBOARD_SIZE; i++) {
        bestScores[i] = 0;
    }

    initialize();
    drawFullScreenImageDMA(title);
   //drawCenteredString(10, 10, 10, 10, "Let's smash the bees!", RED);
   //waitForVBlank();
   //drawString(80, 50, "Let's smash the bees!", RED);
    //goToStart();
    state = START;
    

   while (1) {
        currentButtons = BUTTONS;

        //waitForVBlank();

        switch (state) {

            case START:
                waitForVBlank();
                goToStart();
                startState();
                break;
            case PLAY:
                playState();
                break;
            case WIN:
                winState();
                break;
            case LOSE:
                loseState();
                break;
            case LEADERBOARD:
                leaderboardState();
                break;
        }

        previousButtons = currentButtons;
    }

    return 0;
}

void initialize(void) {
  //initialise player position and size
    player.row = HEIGHT / 2;
    player.col = WIDTH / 2;
    player.oldRow = player.row;
    player.oldCol = player.col;
    player.height = LEGO_HEIGHT;
    player.width = LEGO_WIDTH;

    //initialise my bees
    //waitForVBlank();
    for (int i = 0; i < MAX_FLIES; i++) {
        flies[i].row = randint(0, HEIGHT - MARGIN - FLY_HEIGHT);
        flies[i].col = randint(0, WIDTH - MARGIN - FLY_WIDTH);
        flies[i].oldRow = flies[i].row;
        flies[i].oldCol = flies[i].col;
        flies[i].height = FLY_HEIGHT;
        flies[i].width = FLY_WIDTH;
        flies[i].active = 1;
    }

    //initialise score and timer
    //waitForVBlank();
    score = 0;
    timer = 600; //1800 for 30 seconds
    frameCounter = 0;
}

void goToStart(void) {
    //waitForVBlank();

    //fillScreenDMA(BLACK);
    //drawFullScreenImageDMA(title);
    //undrawImageDMA(50, 30, 50, 50, title);

    //if(KEY_DOWN(BUTTON_UP, currentButtons)) {
    drawString(80, 50, "Let's smash the bees!", RED);
    //}
    //Don't do waitForVBlank(); here --> flickers the bee

    //Extra credit - sprite animation
    int i = 0;
    waitForVBlank();
    //if (flies[i].active) {
           //drawImageDMA(flies[i].row, flies[i].col, flies[i].width, flies[i].height, fly);
        //}

    
    //bee does not flicker if text is here
    //if(KEY_DOWN(BUTTON_UP, currentButtons)) {
    //drawString(80, 50, "Let's smash the bees!", RED);
    //}
    
    undrawImageDMA(flies[i].row, flies[i].col, flies[i].width, flies[i].height, title);

    

    //waitForVBlank();
        flies[i].oldRow = flies[i].row;
        flies[i].oldCol = flies[i].col;
        flies[i].row += randint(-1, 2);
        flies[i].col += randint(-1, 2);

        // Ensure flies stay within bounds
        if (flies[i].row < 0) flies[i].row = 0;
        if (flies[i].row > HEIGHT/2 - flies[i].height) flies[i].row = HEIGHT/2 - flies[i].height;
        if (flies[i].col < 0) flies[i].col = 0;
        if (flies[i].col > WIDTH - flies[i].width) flies[i].col = WIDTH - flies[i].width;
        //waitForVBlank();

        drawImageDMA(flies[i].row, flies[i].col, flies[i].width, flies[i].height, fly);
    //setting state to start 
    state = START;
}

void startState(void) {
    if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        initialize();
        goToPlay();
    }
}

void goToPlay(void) {
    //fillScreenDMA(BLACK);
    drawFullScreenImageDMA(background);
    state = PLAY;
}

void playState(void) {
    waitForVBlank();
    fillScreenDMA(BLACK);                                    // if screen is black, nothing flickers :)
    //waitForVBlank();
    //waitForVBlank();
    //drawFullScreenImageDMA(background);                   //commented this part out because upper half part of the background flickers
    //waitForVBlank();
    drawPlayer();
    //waitForVBlank();
    drawFlies();
    //waitForVBlank();
    drawScore();
    //waitForVBlank();
    //drawTimer();
    //waitForVBlank();

    // Move player with buttons
    if (KEY_DOWN(BUTTON_UP, currentButtons)) player.row--;
    if (KEY_DOWN(BUTTON_DOWN, currentButtons)) player.row++;
    if (KEY_DOWN(BUTTON_LEFT, currentButtons)) player.col--;
    if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) player.col++;


    //undrawImageDMA(player.row, player.col, player.width, player.height, background);
    // Ensure player stays within bounds
    if (player.row < 0) player.row = 0;
    if (player.row > HEIGHT - player.height) player.row = HEIGHT - player.height;
    if (player.col < 0) player.col = 0;
    if (player.col > WIDTH - player.width) player.col = WIDTH - player.width;

    // Check for collisions with flies
    for (int i = 0; i < MAX_FLIES; i++) {
        if (flies[i].active &&
            player.row < flies[i].row + flies[i].height &&
            player.row + player.height > flies[i].row &&
            player.col < flies[i].col + flies[i].width &&
            player.col + player.width > flies[i].col) {
            // Fly swatted
            flies[i].active = 0;
            score++;
            flies[i].row = randint(0, HEIGHT - MARGIN - FLY_HEIGHT);
            flies[i].col = randint(0, WIDTH - MARGIN - FLY_WIDTH);
            flies[i].active = 1;
        }
    }

    // Update flies positions randomly
    for (int i = 0; i < MAX_FLIES; i++) {
        //undrawImageDMA(flies[i].row, flies[i].col, flies[i].width, flies[i].height, background);
        flies[i].oldRow = flies[i].row;
        flies[i].oldCol = flies[i].col;
        flies[i].row += randint(-1, 2);
        flies[i].col += randint(-1, 2);

        // Ensure flies stay within bounds
        if (flies[i].row < MARGIN) flies[i].row = MARGIN;
        if (flies[i].row > HEIGHT - MARGIN - flies[i].height) flies[i].row = HEIGHT - MARGIN - flies[i].height;
        if (flies[i].col < MARGIN) flies[i].col = MARGIN;
        if (flies[i].col > WIDTH - MARGIN - flies[i].width) flies[i].col = WIDTH - MARGIN - flies[i].width;
    }


    //frameCounter++;
    //if (timer % 60 == 0) {
      //  frameCounter = 0;
        timer--;
    //}
    
    //undrawImageDMA(145, 185, 50, 10, background);
    //waitForVBlank();
    drawTimer();                                                  //just commented this out for the other version if need this comment
    //timer--;

    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        drawFullScreenImageDMA(title);
        goToStart();
    }

    //timer--;
    if (timer <= 0) {
        if (score > 0) {
            updateLeaderboard();
            goToWin();
        } else {
            goToLose();
        }
    }
}

void goToWin(void) {
    //fillScreenDMA(BLACK);
    drawFullScreenImageDMA(background);
    drawString(30, 100, "You Win!", RED);
    drawString(50, 56, "Press Start for Leaderboard", BLACK);
    drawString(70, 55, "Press Select to go to Start", BLACK);
    drawString(90, 100, "Score: ", BLACK);
    char scoreStr[10];
    sprintf(scoreStr, "%d", score);
    drawString(90, 140, scoreStr, BLACK);
    state = WIN;
}

void winState(void) {
    if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
         goToLeaderboard();
    } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        drawFullScreenImageDMA(title);
        goToStart();
    }
}

void goToLose(void) {
    //fillScreenDMA(BLACK);
    drawFullScreenImageDMA(background);
    drawString(30, 100, "You Lose!", RED);
    drawString(50, 56, "Press Start for Leaderboard", BLACK);
    drawString(70, 55, "Press Select to go to Start", BLACK);
    drawString(90, 100, "Score: ", BLACK);
    char scoreStr[10];
    sprintf(scoreStr, "%d", score);
    drawString(90, 140, scoreStr, BLACK);
    state = LOSE;
}

void loseState(void) {
    if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
         goToLeaderboard();
    } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        drawFullScreenImageDMA(title);
        goToStart();
    }
}

void goToLeaderboard(void) {
    //fillScreenDMA(BLACK);
    drawFullScreenImageDMA(background);
    drawLeaderboard();
    drawString(130, 35, "Press Start to Play Again", BLACK);
    drawString(145, 35, "Press Select to go to Start", BLACK);
    state = LEADERBOARD;
}

void leaderboardState(void) {
    if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
        initialize();
        goToPlay();
    } else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        drawFullScreenImageDMA(title);
        goToStart();
    }
}

void drawPlayer(void) {
    drawImageDMA(player.row, player.col, player.width, player.height, lego);
}

void drawFlies(void) {
    for (int i = 0; i < MAX_FLIES; i++) {
        if (flies[i].active) {
            drawImageDMA(flies[i].row, flies[i].col, flies[i].width, flies[i].height, fly);
        }
    }
}

void drawScore(void) {
    char scoreStr[10];
    //undrawImageDMA(150, 15, 55, 10, background);
    sprintf(scoreStr, "Score: %d", score);
    drawString(150, 5, scoreStr, RED);
}

void drawTimer(void) {

    //undrawImageDMA(140, 5, 60, 10, BLACK);

    //waitForVBlank();
    char timerStr[10];
    sprintf(timerStr, "Time :%d", timer / 60);
    drawString(150, 180, timerStr, RED);
}

void updateLeaderboard(void) {
    for (int i = 0; i < LEADERBOARD_SIZE; i++) {
        if (score > bestScores[i]) {
            for (int j = LEADERBOARD_SIZE - 1; j > i; j--) {
                bestScores[j] = bestScores[j - 1];
            }
            bestScores[i] = score;
            break;
        }
    }
}

void drawLeaderboard(void) {

    drawString(10, 87, "LEADERBOARD", BLACK);
    for (int i = 0; i < LEADERBOARD_SIZE; i++) {
        char scoreStr[20];
        sprintf(scoreStr, "%d: %d", i + 1, bestScores[i]);
        drawString(30 + i * 20, 100, scoreStr, BLACK);
    }
}